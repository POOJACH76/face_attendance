import os
import time
import numpy as np
import requests
import mysql.connector
from flask import Flask, request
from werkzeug.middleware.proxy_fix import ProxyFix
from werkzeug.utils import secure_filename
import face_recognition
from PIL import Image, UnidentifiedImageError
from io import BytesIO
import logging
import threading
from mysql.connector import pooling
from tenacity import retry, stop_after_attempt, wait_fixed
import magic

# --- Flask app setup ---
app = Flask(__name__)
app.wsgi_app = ProxyFix(app.wsgi_app)

UPLOAD_FOLDER = os.path.join("static", "uploads")
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}
MAX_FILE_SIZE_MB = 5

# --- Middleware to strip Server header ---
class StripServerHeaderMiddleware:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        def new_start_response(status, headers, exc_info=None):
            filtered_headers = [(k, v) for k, v in headers if k.lower() != 'server']
            return start_response(status, filtered_headers, exc_info)
        return self.app(environ, new_start_response)

app.wsgi_app = StripServerHeaderMiddleware(app.wsgi_app)

@app.before_request
def block_unsafe_methods():
    if request.method not in ['GET', 'POST']:
        return "405 Method Not Allowed", 405

@app.after_request
def apply_security_headers(response):
    response.headers['Content-Security-Policy'] = (
        "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; "
        "img-src 'self' data: http://172.21.91.215; object-src 'none';"
    )
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['Referrer-Policy'] = 'no-referrer'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    return response

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

IMAGE_BASE_URL = "https://sjed.rajasthan.gov.in/public/uploads/begger/"
DB_CONFIG = {
    'host': '172.21.83.81',
    'user': 'db_read',
    'password': 'DB_read@123#',
    'database': 'sjed_homes',
    'port': 3306
}
connection_pool = pooling.MySQLConnectionPool(pool_name="face_pool", pool_size=10, **DB_CONFIG)

face_database = []
encodings_array = []
last_cache_time = 0
CACHE_INTERVAL = 300
face_recognition_lock = threading.Lock()

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def is_valid_mime(file_path):
    mime = magic.from_file(file_path, mime=True)
    return mime in ['image/jpeg', 'image/png']

def is_valid_image(file_path):
    try:
        with Image.open(file_path) as img:
            img.verify()
        return True
    except (UnidentifiedImageError, IOError):
        return False

@retry(stop=stop_after_attempt(3), wait=wait_fixed(2), reraise=True)
def download_image(url):
    try:
        logger.info(f"Downloading image: {url}")
        response = requests.get(url, timeout=5, verify=False)
        if response.status_code == 200 and 'image' in response.headers.get('Content-Type', ''):
            img = Image.open(BytesIO(response.content)).convert("RGB")
            return np.array(resize_image(img))
    except requests.RequestException as e:
        logger.error(f"Download error: {url} - {e}")
        raise
    return None

def resize_image(image, max_size=(800, 800)):
    image.thumbnail(max_size)
    return image

def fetch_face_data():
    global face_database, encodings_array, last_cache_time
    try:
        conn = connection_pool.get_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("""
            SELECT bd.begger_uuid, bd.beggar_name, bd.rehab_id, bd.address AS beggar_address, bd.photo AS beggar_photo,
                   rm.rehab_center_name, rm.rehab_address
            FROM begger_details AS bd
            JOIN rehab_mstrs AS rm ON bd.rehab_id = rm.id
            WHERE bd.photo IS NOT NULL AND bd.photo != '';
        """)
        records = cursor.fetchall()
        cursor.close()
        conn.close()

        temp_database = []
        temp_encodings = []
        for record in records:
            photo_name = record["beggar_photo"].strip()
            if not photo_name:
                continue
            try:
                image_url = IMAGE_BASE_URL + photo_name
                image_array = download_image(image_url)
                if image_array is not None:
                    locations = face_recognition.face_locations(image_array, model="hog")
                    encodings = face_recognition.face_encodings(image_array, known_face_locations=locations)
                    if encodings:
                        record["encoding"] = encodings[0]
                        temp_database.append(record)
                        temp_encodings.append(encodings[0])
            except Exception as e:
                logger.warning(f"Encoding failed for {photo_name}: {e}")
        face_database[:] = temp_database
        encodings_array[:] = temp_encodings
        last_cache_time = time.time()
        logger.info(f"Face database loaded with {len(face_database)} records.")
    except mysql.connector.Error as err:
        logger.error(f"Database error: {err}")

def get_face_data():
    global last_cache_time
    if time.time() - last_cache_time > CACHE_INTERVAL or not face_database:
        fetch_face_data()
    return face_database, encodings_array

def match_face(filepath, threshold=0.6):
    with face_recognition_lock:
        try:
            input_image = face_recognition.load_image_file(filepath)
            locations = face_recognition.face_locations(input_image, model="hog")
            encodings = face_recognition.face_encodings(input_image, known_face_locations=locations)
            if not encodings:
                return {"message": "No face detected."}

            input_encoding = encodings[0]
            database, known_encodings = get_face_data()

            if not known_encodings:
                return {"message": "No known faces available."}

            distances = face_recognition.face_distance(known_encodings, input_encoding)
            matched_indices = np.where(distances < threshold)[0]
            if len(matched_indices) == 0:
                return {"message": "No matching face found."}

            matched_results = [
                {
                    "begger_uuid": database[i]["begger_uuid"],
                    "beggar_name": database[i]["beggar_name"],
                    "rehab_center": database[i]["rehab_center_name"],
                    "rehab_address": database[i]["rehab_address"],
                    "photo_url": IMAGE_BASE_URL + database[i]["beggar_photo"],
                    "distance": float(distances[i])
                }
                for i in matched_indices
            ]
            matched_results.sort(key=lambda x: x["distance"])
            return {"matches": matched_results}

        except Exception as e:
            logger.error(f"Face matching error: {e}")
            return {"message": "Error processing image."}

@app.route('/predict', methods=['POST'])
def upload_image():
    if 'image' not in request.files:
        return {"message": "No file part"}, 400

    file = request.files['image']
    if file.filename == '':
        return {"message": "No selected file"}, 400

    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)

        file_size = os.path.getsize(file_path)
        if file_size > MAX_FILE_SIZE_MB * 1024 * 1024:
            os.remove(file_path)
            return {"message": "File too large"}, 400

        if not is_valid_mime(file_path) or not is_valid_image(file_path):
            os.remove(file_path)
            return {"message": "Invalid image file"}, 400

        result = match_face(file_path)
        os.remove(file_path)
        return result, 200

    return {"message": "Unsupported file type"}, 400

if __name__ == "__main__":
    app.run(host="172.21.91.215", port=9000, debug=False)